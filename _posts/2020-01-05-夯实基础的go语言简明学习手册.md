* [1.从go的一些经典面试题说起](#1)
* [2.go语言的优势在哪里](#2)
* [3.go为什么这么快](#3)
* [4.配置本地开发环境](#4)
* [5.go常用命令解析](#5)

* [6.go中基本的语法](#6)
	* [变量](#6.1)

	* [数据类型](#6.2)

		* [Boolean type](#6.21)

		* [Numeric types](#6.22)

			* [Integers](#6.221)

			* [Floating point](#6.222)

			* [Complex numbers](#6.223)
		* [Text types](#6.23)

		* [CONSTANT](#6.24)

			* [Naming convertion(命名转换)](#6.241)

			* [Typed constants(类型化常量)](#6.242)
			* [Untyped constants(取消常量类型转换)](#6.243)
			* [Enumerated constants(编号常量)](#6.244)
			* [Enumeration expressions(计数表达式)](#6.245)

		* [Array and Slices](#6.25)
			* [Array](#6.251)

				* [创建](#6.2511)

				* [内建（built-in）功能](#6.2512)
				* [使用数组](#6.2513)

			* [Slices](#6.252)
				
				* [创建](#6.2521)

				* [内建（built-in）功能](#6.2522)
				* [使用数组](#6.2523)
		* [MAPS AND STRUCTS](#6.26)
			* [Maps](#6.261)
				* [它们是什么?](#6.2611)
				* [Creating(创建)](#6.2612)
				* [操作](#6.2613)
				* [if else与if else if 语句对比](#6.2612)
			* [Structs](#6.262)
				* [它们是什么?](#6.2621)
				* [Creating(创建)](#6.2622)
				* [嵌入](#6.2623)
				* [Tags](#6.2624)
		* [条件流](#6.27)
			* [If 语句](#6.271)
				* [操作符](#6.2711)
				* [if else与if else if 语句对比](#6.2712)
			* [Switch语句](#6.272)
				* [简单事例](#6.2721)
				* [有复合测试的事例](#6.2722)
				* [通过逻辑](#6.2723)
				* [类型switch](#6.2724)
		* [Loop（循环）](#6.28)
			* [For循环](#6.281)
			* [简单loop](#6.282)
			* [提前退出](#6.283)
			* [通过collections进行循环](#6.284)
		* [条件流（高级）](#6.29)
			* [Defer](#6.291)
			* [Panic](#6.292)
			* [Recover](#6.293)
		* [Pointer（指针）](#6.30)
			* [创建指针](#6.301)
			* [取消指针](#6.302)
			* [对对象（复杂数据类型）创建指针](#6.303)
			* [使用nil指针](#6.304)
			* [带有内部指针的Types](#6.305)
		* [Functions（函数）](#6.31)
			* [基本标签](#6.311)
			* [参数](#6.312)
			* [返回值](#6.313)
			* [匿名函数](#6.314)
			* [以函数作为某一类参数](#6.315)
			* [方法](#6.316)
		* [Interfaces](#6.32)
			* [Basics](#6.321)
			* [interface组成](#6.322)
			* [Type conversion](#6.323)
				* [空接口](#6.3231)
				* [Type switches](#6.3232)
			* [接口实现values vs.pointer](#6.324)
			* [最佳实践](#6.325)
		* [GOROUTINES](#6.33)
			* [创建goroutines](#6.331)
			* [Synchronization](#6.332)
				* [WaitGroups](#6.3321)
				* [Mutexes](#6.3322)
			* [Parallelism](#6.333)
			* [最佳实践](#6.334)
		* [Channels](#6.34)
			* [Channel基础](#6.341)
			* [限制数据流](#6.342)
			* [Buffered channels](#6.343)
			* [关闭channels](#6.344)
			* [用channel做for...range循环](#6.345)
			* [select结构](#6.346)



<h2 id="4">配置本地开发环境</h2>
如何为vscode配置支持go语言的开发呢？

![20200329103218](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200329103218.png)
<p class="caption">查看go在本地环境中的详细配置</p>
启动vscode选择文件菜单->首选项->设置，在打开的settings.json文件中粘贴以下代码：
```vscode
"go.buildOnSave": "workspace",
"go.lintOnSave": "package",
"go.vetOnSave": "package",
"go.buildTags": "",
"go.buildFlags": [],
"go.lintFlags": [],
"go.vetFlags": [],
"go.coverOnSave": false,
"go.useCodeSnippetsOnFunctionSuggest": false,
"go.formatOnSave": true,
"go.formatTool": "goreturns",
"go.goroot": "D:\\Go",
"go.gopath": "C:\\Users\\guruYu\\go",
"go.gocodeAutoBuild": false
```

![20200329103911](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200329103911.png)
<p class="caption">vscode帮你自动安装依赖包</p>

但是多数情况下这步不会顺利，因为不但有些库会从github.com往下拉，有些还会从golang.org官网上往下拉会导致网络连接报错，我本地解决的方法如下：

<blockquote>
1、在%GOPATH%\src\ 目录下，建立golang.org 文件夹，并再新建x文件夹。 目录为 "%GOPATH\src\golang.org\x"

2、完成目录切换后，开始下载插件包：
git clone https://github.com/golang/tools.git tools

3、执行完以后，会多一个tools文件夹。

4、打开vsCode终端，切换到 终端，进入“%GOPATH”目录,执行


go install github.com/ramya-rao-a/go-outline

go install github.com/acroca/go-symbols

go install golang.org/x/tools/cmd/guru

go install golang.org/x/tools/cmd/gorename

go install github.com/josharian/impl

go install github.com/rogpeppe/godef

go install github.com/sqs/goreturns

go install github.com/golang/lint/golint

go install github.com/cweill/gotests/gotests

go install github.com/ramya-rao-a/go-outline

go install github.com/acroca/go-symbols

go install golang.org/x/tools/cmd/guru

go install golang.org/x/tools/cmd/gorename

go install github.com/josharian/impl

go install github.com/rogpeppe/godef

go install github.com/sqs/goreturns

go install github.com/golang/lint/golint

go install github.com/cweill/gotests/gotests
</blockquote>

当然上面的方法我本地操作没有完全成功，有些package这种方式是下载成功了，但是保存的时候还是会提示缺少的包，此处放出来，只是给大家做个借鉴。

此种方法安装，中途遇到的问题可能各有不同，比如说我遇到的是原来给github.com拉取设置了proxy，结果proxy失效，导致报错。

![20200330100925](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330100925.png)
<p class="caption">之前给github.com配置过代理报错</p>

我本地原来给github配置过代理，所以报“SOCKS5 read timeout”

>解决方案：
//设置的方法
git config --global https.proxy http://127.0.0.1:1080
>git config --global https.proxy https://127.0.0.1:1080
//取消设置的方法
git config --global --unset http.proxy
git config --global --unset https.proxy

所以我就思考下以前解决类似的思路，比如说python下载package有些时候也奇慢无比或者根本下不下来，这时候就考虑要换源了，python可以换清华大学，豆瓣或者是阿里的源，debian系统更新，依赖ubuntu也可以换源，那这里可不可以换源呢？

所以找到了这个地址[Goproxy 中国](https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md)，与七牛云合作的源，七牛云属于分发大厂，应该还是比较可靠的。

![20200330123721](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330123721.png)
<p class="caption">先查看下自己所用go的版本</p>

然后对应着下面的方法操作：
<blockquote>
用法:
Go 1.13 及以上（推荐）
打开你的终端并执行

\$ go env -w GO111MODULE=on
$ go env -w GOPROXY=https://goproxy.cn,direct
完成。

macOS 或 Linux
打开你的终端并执行

\$ export GO111MODULE=on
$ export GOPROXY=https://goproxy.cn
或者

\$ echo "export GO111MODULE=on" >> ~/.profile
\$ echo "export GOPROXY=https://goproxy.cn" >> ~/.profile
$ source ~/.profile
完成。

Windows
打开你的 PowerShell 并执行

C:\> \$env:GO111MODULE = "on"
C:\> $env:GOPROXY = "https://goproxy.cn"
或者

1. 打开“开始”并搜索“env”
2. 选择“编辑系统环境变量”
3. 点击“环境变量…”按钮
4. 在“<你的用户名> 的用户变量”章节下（上半部分）
5. 点击“新建…”按钮
6. 选择“变量名”输入框并输入“GO111MODULE”
7. 选择“变量值”输入框并输入“on”
8. 点击“确定”按钮
9. 点击“新建…”按钮
10. 选择“变量名”输入框并输入“GOPROXY”
11. 选择“变量值”输入框并输入“https://goproxy.cn”
12. 点击“确定”按钮
完成。
</blockquote>
换完源之后，以下方法都是有效的。

方法一：

打开*.go文件，然后直接保存，保存的时候会提示安装所有依赖，选择“Install All”

方法二：

![20200330122708](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330122708.png)
<p class="caption">在vscode的配置文件settings.json文件中加入如图所示代码，然后reload vscode，会自动提示你下载插件gopls</p>
之后选择“install”，安装完毕reload vscode编辑器，应该就可以了。

我们此时在项目目录下新建一个以.go为结尾的文件，来测试环境是否搭建成功：
```go
//新建文件test.go
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
```

<h2 id="5">go常用命令解析</h2>

- 你可以直接执行go run "SCRIPT_PATH（以.go为后缀的文件）"

- 你也可以用go build "文件所在目录"，此时会在$GOPATH目录下生成一个与“文件所在目录”同名的可执行文件，之后你使用“./文件所在目录（名称）”就可以执行输出了

- 你也可以用go install "文件所在目录",此时会在\$GOPATH/bin目录下生成“文件所在目录”同名可执行文件,$GOPATH目录下用bin/文件所在目录(名称),可执行文件。

![20200330132553](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330132553.png)
<p class="caption">"go env"命令查看找到GOROOT目录</p>

![20200330133130](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330133130.png)
<p class="caption">官网上http package的结构</p>

![20200330133456](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330133456.png)
<p class="caption">本地$GOPATH/src/net下http的结构</p>

还有系统内置的一些package，你可以理解成全局的package，它们存放在$GOROOT/src目录下，我们查看一下http这个package，发现实际上它和官网package菜单下搜到的http的目录结构是一致的。

<h2 id="6">go中基本的语法</h2>

<h5 id="6.1">变量</h5>

![20200330140700](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330140700.png)
<p class="caption">一个可执行的go文件</p>
包括了：

	1. 声明包名
	2. 引入标准库(SPL)
	3. 变量的几种声明方式：
		a:var xx type = value
		c:变量名:=value
![20200330141517](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330141517.png)
<p class="caption">声明类型与赋值不同会报错</p>
<h5 id="6.1">变量的重声明和遮盖</h5>

![20200330142325](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330142325.png)
<p class="caption">已声明的变量不能用":="再次声明赋值，只可以用"="赋值</p>
利用这个特性，可以在函数作用域内部给变量重新赋值，这就是变量的重声明，内部重新声明可以达到遮盖的效果，但是已声明的变量不能再用":="的方式进行声明再赋值，会发生报错。
<h5 id="6.1">变量的可见性</h5>

![20200330142817](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330142817.png)
<p class="caption">变量的可见性</p>
<blockquote>

5.The scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block.

6.The scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.

</blockquote>

官网文档里指出了要点，同样的规则，限制了两件不同的事。首先是声明的变量和常量，声明的变量和常量在使用域内有效；第二点是类型标识，如果在某范围内声明一个类型，相同的作用域规则适用于同范围声明的变量，声明后变量一定要被使用，否则会报错。

同时还要注意go支持的变量声明的规则：

- 小写字母开头是包可见范围

- 大写字母开头是导出package，例如类比一下react native导出模块的语句，export default {Aaa,Bbb}

- 全大写或小写是不限可见范围的，就是在哪都能用

![20200330152208](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330152208.png)
<p class="caption">你给新变量赋值，没指定类型，go给你报错，它不会帮你识别其他变量的类型和值，并不像python，php等脚本语言</p>
<h5 id="6.1">命名转换</h5>

![20200330150810](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330150810.png)
<p class="caption">命名转换</p>
<h5 id="6.1">类型转换</h5>

![20200330150549](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330150549.png)
<p class="caption">引入专用的包做类型转换</p>

把整型转成字符串类型，还可以使用fmt.Sprintf,或者如图所示使用strconv的内置方法Itoa把整型转成字符串类型。

```go
package main

import "fmt"

func main() {
	i := 123
	t := fmt.Sprintf("We are currently processing ticket number %d.", i)#注意只有导入值是才建议这样做，因为它不做任何类型检查，可能会报bug,同时它也比strconv的Itoa方法慢
	fmt.Println(t)
}
```


<h4 id="6.2">数据类型</h4>
<h5 id="6.21">Boolean type</h5>

![20200330175759](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330175759.png)
<p class="caption">Boolean type</p>

布尔类型赋值的方式，其他语言赋值的特性，go的bool类型也同样具备，也就是说除了直接给true,false指定bool值外，还可以用表达式的方式，比如说:
```go
package main

import (//引入多个package时，之间用逗号隔开，同时要注意花括号不能单独占行否则会报错
	"fmt"
)
func main(){
	n := 1 == 1
	m := 1 == 2
	fmt.Println("%v, %T", n, n)
	fmt.Println("%v, %T", m, m)
}
```
<h5 id="6.22">Numberic types</h5>

<h6 id="6.221">Intergers</h6>

![20200330212812](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330212812.png)
<p class="caption">go内置的各整型取值范围对照表</p>

![20200330213434](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330213434.png)
<p class="caption">所以不同类型的整型之间进行算法运算时必须要转成相同的整型类型，否则会报错</p>

![20200330215148](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330215148.png)
<p class="caption">go中的二进制运算</p>

![20200330220401](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330220401.png)
<p class="caption">十进制转二进制</p>
<b>注意：</b>go中的二进运算和其他语言中二进制遵循相同的逻辑，左右位移完毕后，就把越界的部分清除掉，然后用零补位。怎么做十进制转二进制，再把二进制合并成转成10进制输出值，这里讲解一下：
```go
//这里要记住一下要点，从上到下表示的是从右到左的数据顺序，因为数值表示是低位在后，高位在前，所以这里从右到左表示是0101，但是因为正常表示数值高位在前，低位在后，从左到右表示，所以把它逆序过来就是二进制正确的表示方式即1010
//同理下面的从右到左表示为1100，但是高位在前，低位在后，要从左到右表示，所以就是0011
些时两个二进制数相加
1010
0011
0010#运算逻辑就是相同位相加除2，不够除的值为0，都为0也值为0
再把二进制转成十进制就是2（三次方）*0+2（二次方）*0+2（一次方）*1+2（0次方）*0=2，所以返回值为2
#如果是或运算的，与这个逻辑恰好相反，就是能整除2的都落成0，不能整除2的都落成1，所以上图中（a|b)的值就是1011（8+0+2+1=11），不进位加法运算，也就是异或计算，只有不同时候保留相同时都落成0，（a^b)的值就是1001（8+0+0+1=9），&^(AND NOT)，即为位清空运算，它和被运算变量的位置有关系，x&^y==x&(^y),表达成文字的运算规则就是y bit位上的数是0，则取x对应位置上的值，如果y bit位上的值为1，则结果位上取0，所以a&^b的值1000（8+0+0+0=8）。
#顺便说一下左移和右移，其实左移就是做乘方运算，右移就是做开方运算，表现在二进制上就是左右移向对应方向移几位，越界的值都用零补位就行了。
```
同时要记住，int有各种各样的size，但是最小长度是32bits.Intergers范围从8bit到64位，不要把Int理解成Intergers的缩写，Int属于被Intergers包围的关系。Unsigned intergers(无符号的整型)取值范围从8 bit(byte and uint8)到32 bit(uint32)
<h6 id="6.222">Floating point</h6>

![20200330230607](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330230607.png)
<p class="caption">浮点运算</p>

![20200330230830](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330230830.png)
<p class="caption">浮点运算内置了多种浮点类型</p>
 
和前面整型运算一样，也要注意到float也分32、64的版本,只有转成相同的浮点类型才能进行运算。浮点类型是遵循IEEE-745标准的，浮点类型中Zero的值是0，浮点中的语义类型（Literal Styles)包含有Decimal(3.14)类型，这和我们mysql中建表指定需要做精度运算时指定的decimal是一个含义，Exponential(指数类型，如13e18或2E10)类型及Mixed(13.7e12)。

<h6 id="6.223">Complex numbers</h6>

Zero的值在Complex numbers的情况下是(0+0i),包含有64bit和128bit的版本，go内置了如下方法：

- complex(把两个float类型转成一个complex numbers)

- real(以float数据类型返回complex numbers)

- imag(以float数据类型返回虚数[imaginary]部分)

<h5 id="6.23">Text types</h5>

![20200330231155](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330231155.png)
<p class="caption">不要试图改变定义好字串的值结构</p>
包括(String)字符串类型，对它要强调的点是：

- UTF-8编码

- immutable(不可变)

- 可以用plus(+)操作符进行合并

- 可以转换成byte型数组[]byte

Rune类型，对它强调的点是：

- UTF-32编码

- 别名int32

- 通常需要指定方法被执行(e.g.strings.Reader#ReadRule)

<h4 id="6.24">常量类型</h4>

![20200331082748](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331082748.png)
<p class="caption">常量中也存在值遮盖现象</p>
常量使用，有以下点需要提示：

- 不可变，但可以发生常量值遮盖。常量值也有各自的作用域，会出现常量遮盖，比如说你在函数体内声明某个常量，在go文件的runtime结构体中也声明了该常量，那么函数体内部的常量值会覆盖runtime结构体内的声明值。另外，同类型的变量常量可以直接做算术运算等，不同类型也要像变量一样，先转成相同类型再进行运算。

- 在解析时常量值如果未声明类型，解析器会指定类型

- 命名规范同变量相似，驼峰结构用于常量导出，小写字母开头是package内部使用常量。

<h5 id="6.241">Naming convertion(命名转换)</h5>

![20200331082308](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331082308.png)
<p class="caption">常量声明的方式和你变量中用var xx type声明的方式很类似</p>

![20200331083143](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331083143.png)
<p class="caption">constant允许你不声明常量类型</p>


![20200331090400](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331090400.png)

<h5 id="6.242">Typed constants(类型化常量)</h5>

它的生效方式和不可变变量，有以下点需要提示：

- 只有相同类型的常量才能进行算术或其他操作

<h5 id="6.243">Untyped constants(取消常量类型转换)</h5>

提示：

- 同上，只有相同类型才可以进行相关操作

<h5 id="6.244">Enumerated constants(编号常量)</h5>

![20200331083510](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331083510.png)
<p class="caption">"iota"识别符在常量声明中被使用，可以简化递增数值的定义，因为它被用在表达式中，它提供了超越枚举的通用性</p>

![687](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f312a7366414854337a6b2d576a7853445249444d706461412e676966.gif)
<p class="caption">图示"iota"执行方式以便于理解</p>

当"iota"作为值出现在包含有const定义的代码中时，iota所在行立即被reset成0，然后它后面的行按常量规范，一行一行递增。这种方式可以简化有递增需求的常量定义的场景，即首行常量值设置成"iota",后面行常量名称之后什么都可以不跟，但是递增的常量内容就被定义出来了。

提示：

- 特殊符号"iota"允许关联常量轻松创建

- Iota初始值为0，之后每行常量代码递增1

- 注意常量与变量中的0值是一致的

<h5 id="6.245">Enumeration expressions(计数表达式)</h5>

提示：

- 在脚本被编译时才确认操作是被允许的，这点要跟变量区分开，变量你如果变量类型、值没有预先声明好，gofmt的格式检查都过不了，golint直接就会提示，涉及以下：

	- 算术运算

	- Bitwise运算

	- 位移运算


<h4 id="6.25">Array and Slice(数组和切片)</h4>

<h5 id="6.251">Array</h5>
给array一个定义：相同类型数据的集合，长度可变，以0作为索引起始。go中可以使用len关键字返回array的长度。做copy操作时是在引用不同的基础数据；

<h6 id="6.2511">创建</h6>
提示：

![20200331114316](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331114316.png)
<p class="caption">方法一</p>

![20200331114739](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331114739.png)
<p class="caption">方法二</p>

![20200331115205](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331115205.png)
<p class="caption">方法三</p>

![20200331115914](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331115914.png)
<p class="caption">方法四</p>

![20200331120826](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331120826.png)
<p class="caption">方法五</p>

- 可以采用相同变量名，连续赋值的方式，也可以用前面用过的方式 var a[3] int。（方法一)

- 声明长度，类型及赋值（方法二）

- 长度声明用三个点代替"..."，表示可变长度（方法三）

- 先声明数组变量名，再通过下标赋值（方法四）

- 变量copy，并通过下标改变值，这里要注意与其他语言相通的地方，就是引用传值“b=&a”,此时引用的是同一块内存地址，你对b做任何改变，变量a会受影响(方法五)

<h6 id="6.2512">内建（built-in）功能</h6>
<h6 id="6.2513">使用数组</h6>

<h5 id="6.252">Slices</h5>
slice的起效源于有数组类型的支持。
<h6 id="6.2521">创建</h6>

![20200331122448](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331122448.png)
<p class="caption">python切片操作</p>

![20200331122205](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331122205.png)
<p class="caption">方法一</p>

![20200331123714](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331123714.png)
<p class="caption">方法二</p>

提示：
- go中的切片操作与python的切片操作类似，但是go中没有反向切片的概念，比如说python中a[:-1]这种可以从头取到倒数第二个元素，但是go中必须正着取，如果你想取到倒数第二个元素要用a[:len(a)-1]。（方法一）

```go
package main

import (
	"fmt"
)
func main() {
	a := [...]int{1,2,3,4,5}
	fmt.Println(a[:len(a)-1])
}
```

- 用make关键字，参数含义分别是数组填充值类型、长度、容量（方法二）

![20200331124159](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331124159.png)
<p class="caption">go中slice类型append关键字</p>

- append关键字，向数组中添加元素，添加时还要注意，如果你声明数组元素类型是int的话，那么你不能用append(a,{1,2,3,4,5})的方式来添加会报错，这时可以用"..."关键字a = append(a,[]int{1,2,3,4,5}...)。

<b>
注：

a.容量关键字非必须，根据实际需要决定是否指定，切片的取值是不包含边界值的，比如说a[:2],实际取的是数组a中的0和1号元素。

b.如果基础数组太小，append函数会引起昂贵的副本操作，所以，在基础数组比较小的时候，尽量避免使用append关键字。

c.做copy时实际上是引用的相同基础数组。

</b>
<h6 id="6.2522">内建（built-in）功能</h6>
提示：

- len函数返回slice的长度

- cap函数返回基础array的长度。


<h6 id="6.2523">使用Slices</h6>


![20200331123302](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331123302.png)
<p class="caption">用下标赋值的方式覆盖原值</p>

<h4 id="6.26">MAPS AND STRUCTS</h4>

<h5 id="6.261">Maps</h5>
提示：

- 通过key值来访问maps中的元素，myMap["key"]="value"

- 通过迭代或者是make方法来创建

- 可以通过"value,ok"来检测值的存在
```go
func main() {
	dict := map[string]int {"foo" : 1, "bar" : 2}
	if value, ok := dict["baz"]; ok {
		fmt.Println("value: ", value)
	} else {
		fmt.Println("key not found")
	}
}
```

- 多重赋值引用相同的基础数据

<h6 id="6.2611">它们是什么?</h6>

<h6 id="6.2612">Creating(创建)</h6>

![20200331153744](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331153744.png)
<p class="caption">创建map的基础方式</p>

提示：

- 创建map可以直接如图所示map关键字方括号里写key的类型，紧接着指定值的类型，最后是赋值部分。

- 也可以用make(map[string]int)方式来指定创建map的键值组成。

<h6 id="6.2613">操作</h6>

![20200331155038](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331155038.png)
<p class="caption">delete删除map中元素</p>

提示：

- 可以用map[key]=value方式往map中添加元素；

- 可以用delete关键字从map中删除元素； 

<h5 id="6.262">Structs</h5>
提示：

- 不同数据类型描述一个相同概念的集合

- 命名的字段名称作为key

- 常规需要指定type关键字来创建，但是允许匿名创建 

- struct是一种值类型

- 没有继承概念，但是可以通过嵌入的方式进行合成

- tag可以被加到struct的字段名称中描述字段。

<h6 id="6.2621">它们是什么?</h6>

提示：

在计算机科学里，被称为相关数组、map、符号表或者是字典，是由一组<key,value>对组成的抽象数据结构，并且同一个key只会出现一次，这个概念跟其他语言中数组的概念数组概念很像，但是go语言里的array是代表着相同类型数据的集合，跟其他语言对关键字的定义有差异。map存在的形式通常有两种，一种是哈希查找表（Hash table),另外一种是搜索树（Search tree)。

哈希表通过一个哈希函数把key分配到不同的桶上，这样开销主要花在哈希函数的计算以及数组的常数访问时间上，会存在一个问题，就是不同的key被索引到了相同的bucket上，解决方式有两种:

- 链表法，将一个bucket实现成一个链表，落在同一个bucket上的key都会插入到这个链表中。

- 开放地址法，发生碰撞以后，通过一定既定规则的运算，从后面挑选“空位”来放置新key。

搜索树一般采用自平衡搜索树，包括AVL树和红黑树，还有现在也有使用的SB树，自平衡树的好处是如果做查找返回的key序列是按从小到大排列的，这点就跟哈希表结构不同，它返回的key的顺序是杂序。

所以就可以把map理解为一个高效增删改查的数据结构，搜索树最差的时间复杂度为logN,而哈希表最差的时间复杂度为N，但是基本见不到这种情况的时间复杂度，平均情况来说，哈希表的查找效率还是非常高的，几乎可以认为是1，系统缺少这么高效有同时可以对很多字段类型存储又进行增删改查操作的数据类型，那肯定算不上一门很优秀的语言了，所以go中map就这样产生了。

<h6 id="6.2622">Creating(创建)</h6>

![20200331155924](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331155924.png)
<p class="caption">方法一</p>

![20200331160915](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331160915.png)
<p class="caption">方法二</p>

![20200331162005](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331162005.png)
<p class="caption">方法三</p>

提示：
 
- 用type 结构名 struct声明出struct,然后在使用的部分，对应着字段名称、字段类型来赋值（方法一）

- 直接在调用声明并赋值（方法二）

- 把现有结构赋值给变量，然后通过key来改变生成变量的值组成值（方法三）。此种方式如前面讲过引用传值一样，任何对副本结构的改变都会体现在基础结构数据中。

<h6 id="6.2623">嵌入</h6>

![20200331163029](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331163029.png)
<p class="caption">合并</p>

提示：

- 在go中的在一个结构中引入另外一个结构，可以理解为它“继承”的方式，用于扩展结构体

<h6 id="6.2624">Tags</h6>

![20200331165003](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200331165003.png)
<p class="caption">Tag的使用</p>

提示：

- tags用于在struct中，以"`"符号引入


<h4 id="6.27">条件流</h4>

<h5 id="6.271">If 语句</h5>
提示：

- 可以在if中做变量声明，但是如果声明了变量就不要加圆括号否则会报错
```go
//这样是正确的
if n := 15; n%2 == 0 {
	fmt.Printf("%d is even\n", n)
} else {
	fmt.Printf("%d is odd\n", n)
}
//这样是会报错的
// if中包含变量声明 不能用圆括号
if (n := 15; n%2 == 0) { // Syntax Error

}
```
![20200402103007](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402103007.png)
<p class="caption">涉及到float类型的精度运算数值比较要注意，这种情况不相等</p>

![20200402103207](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402103207.png)
<p class="caption">转成这种方式做比较就相等</p>
<h6 id="6.2711">操作符</h6>
<h6 id="6.2712">if else与if else if 语句对比</h6>
提示：

- 像其他语言，比如python一样，对特定逻辑做捕捉执行可以用单if，如果要涵盖全逻辑，各逻辑分支对应不同执行用if else if语句。

```go
package main
import "fmt"

func main() {
	var BMI = 21.0
	if BMI < 18.5 {
		fmt.Println("You are underweight");
	} else if BMI >= 18.5 && BMI < 25.0 {
		fmt.Println("Your weight is normal");
	} else if BMI >= 25.0 && BMI < 30.0 {
		fmt.Println("You're overweight")
	} else {
		fmt.Println("You're obese")
	}
}
# Output
Your weight is normal
```
<h5 id="6.272">Switch语句</h5>

```go
package main
import "fmt"

func main() {
	var dayOfWeek = 6
	switch dayOfWeek {
		case 1: fmt.Println("Monday")
		case 2: fmt.Println("Tuesday")
		case 3: fmt.Println("Wednesday")
		case 4: fmt.Println("Thursday")
		case 5: fmt.Println("Friday")
		case 6: {
			fmt.Println("Saturday")
			fmt.Println("Weekend. Yaay!")
		}
		case 7: {
			fmt.Println("Sunday")
			fmt.Println("Weekend. Yaay!")
		}
		default: fmt.Println("Invalid day")
	}
}
# Output
Saturday
Weekend. Yaay!
```
提示：

- switch中支持break关键字，声明以后，中断执行，但是不声明go内置捕获事件成功，自动终止执行，所以加不加意义不大；

<h6 id="6.2721">简单事例</h6>

![20200402104300](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402104300.png)
<p class="caption">的switch结构中对变量进行声明是支持的，但是不要加括号，否则会报错</p>
提示：

- switch中是支持声明与声明后变量值作为判断条件的，但是注意声明部分不要加括号，否则会报错；

<h6 id="6.2722">有复合测试的事例</h6>
提示：

- switch语句是支持复合条件判断的，但是注意复合条件在各case分支中不能有重合，否则会报错；

![20200401005551](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200401005551.png)
<p class="caption">如果switch的不同分支判断有重合会报错</p>

<h6 id="6.2723">通过逻辑</h6>

提示：

- switch会从上到下执行case内逻辑直到有一个case执行成功就不再执行，与c、c++、java等不同，这些语言需要你自己在case内明确声明break关键字来终止执行

- 如果所有case都未匹配被执行，则执行default block部分代码。

![20200402105816](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402105816.png)
<p class="caption">fallthrough的含义就是control flow不会从当前case出来，但是会进入下一个case流</p>

- fallthrough关键字的使用，看文档中的说法：
>In a case or default clause, the last non-empty statement may be a (possibly labeled) "fallthrough" statement to indicate that control should flow from the end of this clause to the first statement of the next clause. Otherwise control flows to the end of the "switch" statement. A "fallthrough" statement may appear as the last statement of all but the last clause of an expression switch.

<h6 id="6.2724">类型switch</h6>

![20200402110157](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402110157.png)
<p class="caption">interface不是内置的数据类型，是一种结构的声明，具体的值由后边赋值部分决定</p>

<h4 id="6.28">Loop（循环）</h4>

<h5 id="6.281">For循环</h5>



![20200402112033](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402112033.png)
<p class="caption">支持多参数循环</p>

![20200402112613](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402112613.png)
<p class="caption">省略写法，不要遗漏分号</p>

提示：

![20200402113250](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402113250.png)
<p class="caption">简写</p>

- 支持省略变量声明及变量步长规律，只写取值范围，也有效（如上图），两侧也可加分号，没区别；


<h5 id="6.282">简单loop</h5>

![20200402111535](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402111535.png)
<p class="caption">最简单的for循环，i++部分也可以改成你需要的步长令i=i+N即可</p>
<h5 id="6.283">提前退出</h5>

![20200402113829](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402113829.png)
<p class="caption">提前退出</p>

![20200402114356](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402114356.png)
<p class="caption">还是提前退出，外层循环只走了i=1，这里Loop关键字就是“Labels”，你可以自己定义对应一致就行</p>

提示：

- 同样支持continue、break等关键字，与python等脚本语言关键字含义无差别，labels关键字是go特有的；

<h5 id="6.284">通过collections进行循环</h5>

![20200402114708](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402114708.png)
<p class="caption">通过collecgtions进行循环</p>

提示：

- 如果collections是字符串，循环打印key,value，value返回值是对应字符串的编码号，加上string()关键字就会返回对应的英文字母；

<h4 id="6.29">条件流（高级）</h4>

<h5 id="6.291">Defer</h5>

![20200402120628](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402120628.png)
<p class="caption">defer关键字使语句延迟执行，遵循后进先出的原则</p>

![20200402121316](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402121316.png)
<p class="caption">句柄关闭语句提前，如果不加defer只能打印状态码，加了defer打印部分正常执行输出，这些主体执行完毕，关闭句柄语句最后执行</p>

提示：

- 延迟执行，一直到函数功能结束之前才被调用；
- 通过和open或者close功能绑定在一起使用；
	- 在循环中小心使用，因为在所有函数功能执行完毕前才会被调用；
- 以LIFO（last in first out)顺序执行defer修改的部分；
- 参数在defer修饰部分执行的时候被赋值，而不是函数被调用时就赋值；

<h5 id="6.292">Panic</h5>

![20200402124226](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402124226.png)
<p class="caption">panic终止了函数执行</p>

提示：

- 被调用时程序不再执行
	- 在文件无法被打开时不要使用此命令，除非特别关键，有特殊需要，不然后面逻辑都执行不到；
	- 在不可恢复事件中可以使用，比如说tcp通过端口方式连接web服务连不上情况下，后边逻辑都执行不到，果断捕获输出；
- panic可以停止你正常函数功能，如果程序内有defer调用，那defer中的功能正常执行；
- 如果未对panic做任何处理，程序将退出，所以panic捕获以后，要有自己的应对机制，而不是终止程序运行就完了。
<h5 id="6.293">Recover</h5>
提示：

- Recover是内建的用来恢复goroutine被panic终止程序的，它只在有defer被使用的结构中有效，如果是正常的抛异常，调用Recover将返回nil，并无其他影响。如果当前执行的goroutine正处在panicking状态，对Recover的调用将捕获到给panic传的值同时将异常恢复成正常状态；
```go
package main

import "fmt"

func main() {
    f()
    fmt.Println("Returned normally from f.")
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()
    fmt.Println("Calling g.")
    g(0)
    fmt.Println("Returned normally from g.")
}

func g(i int) {
    if i > 3 {
        fmt.Println("Panicking!")
        panic(fmt.Sprintf("%v", i))
    }
    defer fmt.Println("Defer in g", i)
    fmt.Println("Printing in g", i)
    g(i + 1)
}
输出结果将是：
Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
Recovered in f 4
Returned normally from f.
如果从整个控制流中移除defer关键字，输出将是这样：
Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
panic: 4

panic PC=0x2a9cd8
[stack trace omitted]
//因为终止正常流程执行的recover不会被调用，因为panic终止了
//正常执行的控制流程，到达了goroutine调用栈的顶部，终止了程序；
```
- 当前函数将不再继承执行，但是在调用栈层面更前置的函数功能将不受影响；

<h4 id="6.30">Pointer（指针）</h4>

<h5 id="6.301">创建指针</h5>

![20200402134540](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402134540.png)
<p class="caption">用引用传值的方式对b赋值并指定数据类型为指针（带*号），则打印值中返回内存引用地址</p>

提示：

- 指针类型使用星号（\*）来指定；
	- *int-指向整型的指针
	- 引用传值方式把当前值赋值给指定了指针类型的值，此时做打印返回引用的内存地址，如果想打印出原值对应的数字，可使用fmt.Println(a,*b)

![20200402135743](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402135743.png)
<p class="caption">此时b、c变量值是对应的内存地址，无法做算术运算</p>

- 使用符号（&）获取变量所在内存地址；
- 被赋值成指针类型的变量不能做算术运算；

![20200402141009](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402141009.png)
<p class="caption">a没有声明数据长度</p>

![20200402141148](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402141148.png)
<p class="caption">a声明了数据长度</p>

<b>注：前面已经做过强调，引用传值赋值的新变量和原变量变量指向了相同的内存地址，此时对新变量或者原变量的任何更改，在两变量中都体现，但是要注意上述两图声明长度与否导致副本机制改变的影响</b>
<h5 id="6.302">取消指针</h5>
提示：

- 通过在变量前添加星号（*）来取消指针，注意区分声明和取消应用的场景；
- 复杂类型（如自定义的struct）自动取消指针，因为通常输出地址给你你也没什么用；
<h5 id="6.303">对对象（复杂数据类型）创建指针</h5>

![20200402140413](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402140413.png)
<p class="caption">new关键字的使用</p>
提示：

对对象创建指针：

- 如果值类型已经存在，可以使用地址引用符（&）
	- ms := myStruct{foo:42}
	  p  := &ms 
- 在初始化前加上地址引用符（&）
	- &myStruct{foo:42}
- 使用new关键字
	- 无法在使用new的同时初始化字段
<h5 id="6.304">使用nil指针</h5>
提示：

- 任何为空判断都可以用nil做比较值
<h5 id="6.305">带有内部指针的Types</h5>
提示：

- go中所有赋值操作都是副本操作
- slice(切片）和map数据类型都包含自身指针，指针结构与基础数据相同


<h4 id="6.31">Functions（函数）</h4>

<h5 id="6.311">Functions（函数</h5>

![20200402145105](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402145105.png)
<p class="caption">函数的基本结构func关键字、函数名称、参数、花括号里的函数体也就是处理逻辑</p>
提示：

- 一个函数的组成：
```go
function foo(){
	...
}
```
<h5 id="6.312">参数</h5>

![20200402152151](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402152151.png)
<p class="caption">传参里"..."代表可变长度，这个我们前面已经说过了</p>
提示：

- 使用空格区分参数的名称和类型
- 如果是相同类型的话可只声明一次类型
```go
func foo(bar, baz int){
	...
}
```

![20200402174207](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402174207.png)
<p class="caption">当指定函数返回值属于哪个struct时实际做的都是副本拷贝，你在函数上做任何修改都不会影响输出值</p>

![20200402174526](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402174526.png)
<p class="caption">当指定函数返回值属于指针类型的struct以后，你函数上对struct结构内值做的任何修改都会体现出来</p>

我们看下这种指定struct的指针类型作为函数返回值过程中发生了什么？
<blockquote>

1.我们在方法定义中使用"*Employee"改变了参数接收类型为struct的指针类型，用这种方式，赋值给"e"时，"e"实际指向的是这个方法被调用struct object; 

2.在方法体中，我们用"(\*p)"方式取消指针，此时e从指针类型变成了值类型，因此"(\*e)"此时就是定义的struct存在于内存中的值；

3.然后我们改变”e“的name字段值，这里的任何改变都将影响原始结构；

4.在”main“方法中，我们创建了一个指针”ep“指向”e“这个struct; 

5.因为changeName方法属于”Employee“的指针类型（type *Employee）,它可以对type *Employee的值进行调用；

6.因为”ep“是*Employee,我们可以使用changeName方法对它进行修改，所以有”ep.changeName()“操作，这就导致把”ep“的指针传给了方法作为了返回值，此时已经不是开始赋值”e“的值了。
//以上过程，你也可以不用为了使用changeName方法改变值，从e上专门创建一个新指针ep，(&e).changeName("Monica Geller")同样有效；
</blockquote>

- 当传入值为指针类型时，函数被调用时可以改变值（如上面的分析）；
- 可以用可变长度参数传入一系列类型相同的值
	- 如果用可变长度参数，只能作为最后一个参数
	- 以切片结构被函数接收
	- func foo(bar string,baz ...int)


<h5 id="6.313">返回值</h5>

![20200402153105](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402153105.png)
<p class="caption">直接声明返回值类型，同时要符合算法运算规则</p>

提示：

- 单返回值时只列出类型
	- func foo() int
- 多返回值时列出用圆括号包裹的类型
	- func foo() (int, error)
	- (return type,error)是通用格式
- 可以使用命名的返回值
	- 初始化返回变量
	- 直接return不用再指定结果值名称
- 可以返回本地变量的地址
	- 自动从本地内存（stack)到共享内存（heap)
<h5 id="6.314">匿名函数</h5>

![20200402153802](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402153802.png)
<p class="caption">匿名函数，注意函数结尾那个"()"</p>

提示：
- 函数如果没有命名，又有如下结构，那它是匿名函数：
	- 立即触发型
		```go
		func(){
			...
		}()
		```
	- 被赋值给一个变量或者作为函数的参数
		```go
		a :=func(){
			...
		}
		a()
		```
<h5 id="6.315">以函数作为某一类参数</h5>

![20200402154918](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402154918.png)
<p class="caption">声明变量后以可执行匿名函数作为值完成赋值</p>

![20200402164723](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402164723.png)
<p class="caption">参数类型，返回值类型及报错捕获都在声明函数功能时声明出来，具体函数功能里要对应一致</p>

提示：

- 可以分配函数给变量或者用来做参数并在函数里返回值
- 类型标签跟函数标签都没有参数名称
	- var f func(string, string, int) (int, error)
<h5 id="6.316">方法</h5>

![20200402172029](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402172029.png)
<p class="caption">method就是function，只不过多传了一个由它产生的返回值名称和类型（隶属于什么struct）</p>

提示：

- 函数在指定类型的上下文中调用就成了方法
- 格式
	```go
	func (g greeter) greet(){
		...
	}
	```
- 方法调用的返回结果可以是值或者指针（通俗点讲就是声明返回值为什么就得返回什么）
	- 值类型只接受类型的拷贝
	- 指针类型只接受类型的指针

<h4 id="6.32">Interfaces</h4>

提示：
- 接口的实现是隐式的，也就是说接口不由reciever决定，而是由创建者决定；
- 声明的接口被使用，这里使用就是指你实现接口里定义的方法
- 如果你的接收者类型被指定成了指针，那么，在你调用被在接口中实现方法的时候，你就不能直接指定方法名来调用方法，而是需要前面加”&“符号，即采用指定地址的方法来调用
- interface内部的组成是一个接口类型，一个是值，它的值可以是真实值，也可以是一个指针，如果是真实值，它就是基础数据的副本（原始拷贝），如果是指针，赋值操作可以看成是接口的值或指针放进声明变量的肚子里
- 想知道接口在go运行时装的类型和值到底是什么？
	```go
	r=&AAA.Retriever{
		aaa:"aa",
		bbb:"bb"
	}
	switch v := r.(type){
		case X.Reciever://X记为外部引入的package
			fmt.Println("Contents:",v.Contents)
		case *AAA.Reciever:
			fmt.Println("aaa:",v.aaa)
		default:
			fmt.Println("i don't know what in you")
	}
	//另一种方式是采用type assertion(内容断言),也可以打印出接口内到底类型和值到底是什么
	aaaRetriever := r.(*aaa.Retriever)
	fmt.Println(aaaRetriever.bbb)
	```

<h5 id="6.321">Basics</h5>

![20200402202449](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402202449.png)
<p class="caption">interface的基本使用，定义出接口功能，然后函数实现具体的接口方法</p>

![20200402211731](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402211731.png)
<p class="caption">针对IntCouter返回值类型实现了接口中定义的Increment方法</p>

```go
type Writer interface{
	Write([]byte)(int,error)
}

type ConsoleWriter struct{}//定义struct

//定义函数 并指定返回值的struct为ConsoleWriter 同时实现interface Writer的write方法
func (cw ConsoleWriter) Write(data[]byte)(int,error){
	n,err := fmt.Println(string(data))
	return n,err
}
```

<h5 id="6.322">interface组成</h5>

```go
//声明不同用途的接口 然后合并到一个总的接口声明里面 最终使用时以总的声明接口为标准
type Writer interface{
	Write([]byte)(int,error)
}

type Closer interface{
	Close() error
}

type  WriterCloser interface{
	Writer
	Closer
}
```

<h5 id="6.323">Type conversion</h5>

```go
var wc WriterCloser = NewBufferedWriterCloser()
bwc := wc.(*BufferedWriterCloser)
```
<h6 id="6.3231">空接口</h6>
提示：

- var i interface{}=0

<h6 id="6.3232">Type switches</h6>

	```go
	switch i.(type){
		case int:
			fmt.Println("i am an integer")
		case string:
			fmt.Println("i am a string")
		default:
			fmt.Println("i don't know what i am")
	}
	```
<h5 id="6.324">接口实现values vs.pointer</h5>

![20200402222804](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200402222804.png)
<p class="caption">这样会产生报错，原因在哪里？</p>

通过前面struct章节的学习，我们知道，如果一个函数接受以指针为参数，那么，只要用Struct”对象名称+方法名（如图中取r.Area)“，此时，无论是值类型还是指针类型都能正确返回值，但是这里是接口，有什么不同呢？我们观察到”func (r *Rect) Area()...“这句中\*Rect实际是结构Rect（不带点Rect）没有实现Area方法，只是\*Area实现了。这是因为可以在值或指针上调用带有值或者指针接收器的方法


提示：

- 值类型的方法集合是全部都带有值接收的方法；
- 指针类型的方法集合全部都是方法，不管接收者的类型，也就是说接收者无论是方法，结构等，如果你指定了限定的数据类型为指针，那么都要通过method的方式来对interface进行调用
- 当方法有指针接收者时，不必使用取消指针方式（*e）获得接收者的值，只要用e就能取到指针指向值的地址，go能理解你在试图对值本身进行操作，它会在幕后帮你把e转成\*e
- 函数的接收者（reciever)可以理解为方法（Method），即处理特定一类数据作为函数参数，所以函数是参数的接收者，所以有接收者这个概念；
<h5 id="6.325">最佳实践</h5>
提示

- 细化，使用尽量多且小的接口；
	- 单方法的接口是最强效的也是最复杂的 
		- io.Writer,io.Reader,interface{}
- 不要为类型声明接口会造成与struct的混淆
- 对于将被在package中使用的类型要做导出为接口的处理
- 尽可能的在你的功能和方法设计中，接收接口作为参数，这样可以规范系统的结构


<h4 id="6.33">GOROUTINES</h4>

<h5 id="6.331">创建goroutines</h5>
<h5 id="6.333">Parallelism</h5>

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)
var wg = sync.WaitGroups{}
var counter = 0
var m = sync.RWMutex{}

func main(){
	runtime.GOMAXPROCS(100)
	for i :=0; i<10; i++{
		wg.Add(2)
		go sayHello()
		go increment()
	}
	wg.Wait()
}

func sayHello(){
	m.RLock()
	fmt.Printf("Hello #%v\n",counter)
	m.RUnlock()
	wg.Done()
}

func increment(){
	m.Lock()
	counter++
	m.Unlock()
	wg.Done()
}
```

提示：
- 在函数前使用”go“关键字来创建goroutines
- 当使用匿名函数时，用本地变量的方式来传递数据参数
<h5 id="6.332">Synchronization</h5>
提示：

- 使用”sync.WaitGroup“等待goroutines组执行完毕
- 使用”sync.Mutex“和”sync.RWMutex“去保护数据访问
<h6 id="6.3321">WaitGroups</h6>
提示：

- 作用是可以让更多go的goroutines工作
<h6 id="6.3322">Mutexes</h6>
提示：

- 默认情况下，go会使用跟cpu核数相同的线程数
- 用runtime.GOMAXPROCS来改变并发线程数
- 更多的线程可以增强性能，但是过犹不及，太多了反而会降低性能，这有点哲学的思想在里面
- 注意区分并行（concurrency）和并发（Parallelism）,并发是指一个时间段内有很多的线程或进程在执行，但任何时间点上只有一个在执行，多个线程或进程争抢时间片轮流执行，而并行是指一个时间段和一个时间点上有多个线程或进程在执行，并发程序只有一个垂直的控制逻辑，在任何时刻，程序只会处在这个控制逻辑的某个位置，也就是顺序执行，如果一个程序在某一时刻被多个cpu同时进行处理，那么我们就说这个程序在以并行的形式在运行。并行是需要硬件支持的，如果是单核处理器，就只能并发，多核服务器才能做到并行执行；
- 理解并行和并发之间的关系，并发是并行的必要条件，如果一个程序本身就不是并发的，也就是只有一个逻辑执行顺序，那我们不可能让其做并行处理，但是并发并不是并行的必要条件，一个并发的程序，如果只被一个cpu进行处理（并发是时间轴上轮流的执行，就是有先有后，并不是某个时间节点多个线程或进程在运行，那是并行了），那么它就不是并行的；

<h5 id="6.334">最佳实践</h5>
提示：

- 不要在libraries上创建goroutines
	- 让消费者来控制并发（有点类似于单一职责原则，就是library只解决特定功能点，如何使用gorotine由库的调用者来控制）
- 当创建goroutine时，你要知道何时让它停
	- 避免哪怕很小的内存泄漏

![20200403133518](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200403133518.png)
<p class="caption">命令行运行时加上-race（go run -race src/main.go）参数，可以查看goroutine的使用状况，方便调试你的代码，优化性能</p>

![20200403133940](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200403133940.png)
<p class="caption">加race参数之后控制台输出内容</p>


- 运行时检查race条件



<h4 id="6.34">Channels</h4>
<h5 id="6.341">Channel基础</h5>

![20200403152927](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200403152927.png)

提示：
- 用make命令创建channel
	- make(chan int)
- 往channel里注入消息
	- ch <- val
- 从channel中取出消息
	- val := <-ch
- 可以有多个发送者（sender）和接收者（reciever）

<h5 id="6.342">限制数据流</h5>

提示：
- channel可以指定成send-only或者是recieve-only的版本
	- Send-only:chan <- int
	- Recieve-only:<- chan int
<h5 id="6.343">Buffered channels</h5>
提示：

- channel阻塞sender（发送者）一侧直到reciever(接收者)可用
- 可以用buffered channel分离sender和reciever
	- make(chan int, 50),这里50就是指定了使用buffered channel
- 当sender和reciever有不对称加载时可以使用buffered channel
<h5 id="6.344">关闭channels</h5>
<h5 id="6.345">用channel做for...range循环</h5>


![20200403155214](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200403155214.png)
<p class="caption">用for...range方式对channel进行循环</p>

提示：

- 当channel和执行信息送达时监测它们


<h5 id="6.346">select结构</h5>

![20200403161446](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200403161446.png)
<p class="caption">select语法在channel结构中的使用</p>

提示：

- 允许goroutine一次监测多个channel
	- 如果所有channel都阻塞了则阻塞
	- 如果多个channel同时接收到值，则判定行为为undefined




<h2 id="2">用go创建你的第一个Rest Api</h2>

主要包括三个部分：

#### 1. API
API，Application Programming Interface,含义是暴露功能，但是不暴露功能的内部组成。
#### 2. Rest API
REST是REpresentational State Transfer的缩写，它是
#### 3. Rest API with GO 


 

<h2 id="1">go中经典的那些面试题</h2>

1. 写出下面代码的输出内容
```go
package main
import (
	"fmt"
)
func main() {
	defer_call()
}
func defer_call() {
	defer func() { fmt.Println("打印前") }()
	defer func() { fmt.Println("打印中") }()
	defer func() { fmt.Println("打印后") }()
	panic("触发异常")
}  
```

答：输出内容为:

```go
打印后
打印中
打印前
panic: 触发异常
```

解析：

考察是对defer的理解，defer意为延迟执行，就是在调用return之前被执行，多个defer之间按LIFO先进后出顺序执行。Panic触发时结束函数运行，最后由runtime运行时抛出异常信息。return value这步不是原子操作（最小粒度操作），它实际是分成返回函数赋值和return两步进行的执行，利用defer后进先出的特性，可以把它放到return执行最近之前的位置上来改变返回值，如下:
```go
package main
import (
	"fmt"
)
func main() {
	fmt.Println(doubleScore(0))    //0
	fmt.Println(doubleScore(20.0)) //40
	fmt.Println(doubleScore(49.0)) //40
	fmt.Println(doubleScore(50.0)) //50
}
func doubleScore(source float32) (score float32) {
	defer func() {
		if score < 1 || score >= 100 {//如果传值50就不走乘2为返回值的逻辑了
			//将影响返回值
			score = source
		}
	}()
	score = source * 2
	return
	//或者
	//return source * 2
}
//上述50以内（不包括50）传值都会返回传值*2的结果，如果比1小或大于100就原值返回，利用这种defer逻辑，可以在return执行前改变输出结果
```
2. 以下代码有什么问题，说明原因

```go
package main
import (
	"fmt"
)
type student struct {
	Name string
	Age  int
}
func pase_student() map[string]*student {
	m := make(map[string]*student)
	stus := []student{
		{Name: "zhou", Age: 24},
		{Name: "li", Age: 23},
		{Name: "wang", Age: 22},
	}
	for _, stu := range stus {
		m[stu.Name] = &stu
	}
	return m
}
func main() {
	students := pase_student()
	for k, v := range students {
		fmt.Printf("key=%s,value=%v \n", k, v)
	}
}
```
答：输出的均是相同的值:
```go
&{wang22}
```
解析：

因为for遍历时，变量stu的指针不变，每次只做struct的值拷贝，故m[stu.Name]=&stu实际一致指向同一个指针，最后该指针的值为遍历的最后一个struct的值拷贝，形式如下:
```go
var stu student 
for _, stu = range stus {
	m[stu.Name] = &stu//因为是值拷贝，一直是原值指针的位置
}
```
如何进行修正呢？
```go
for i, _ := range stus {
	stu:=stus[i]//要先取到数组中原始值指针的位置再赋值
	m[stu.Name] = &stu
}
```
3. 下面的代码会输出什么，并说明原因
```go
func main() {
	runtime.GOMAXPROCS(1)
	wg := sync.WaitGroup{}
	wg.Add(20)
	for i := 0; i < 10; i++ {
		go func() {
			fmt.Println("i: ", i)
			wg.Done()
		}()
	}
	for i := 0; i < 10; i++ {
		go func(i int) {
			fmt.Println("i: ", i)
			wg.Done()
		}(i)
	}
	wg.Wait()
}
```
答：会随机输出数字，但是前面循环并不能输出所有值。

解析：GOMAXPROC设置为1，将会影响goroutine的并发，后续代码中go func()相当于串行执行。虽然两个都是变量i，但是调用值的方式不同，导致意义也完全不同，第一个i是外部for循环遍历生成的一个变量，指向内存地址不变化，遍历完成后i=10，故i的值始终等于10；第二个i是函数的实参，尾部i将发生拷贝，go func内部将指向拷贝地址。

4. 下面代码会输出什么？
```go
type People struct{}
func (p *People) ShowA() {
	fmt.Println("showA")
	p.ShowB()
}
func (p *People) ShowB() {
	fmt.Println("showB")
}
type Teacher struct {
	People
}
func (t *Teacher) ShowB() {
	fmt.Println("teacher showB")
}
func main() {
	t := Teacher{}
	t.ShowA()
}
```
答：将输出：
```go
showA
showB
```

解析：go中没有继承，只有组合，并不像我们写java,php,python时候有类的继承的说法，这里people是匿名组合People,被组合的people中的方法虽然被升级成了外部类型Teacher这个组合类型的方法，但他们方法（showA()）调用时接收者并没有发生实质改变，这里仍然是People,这里People并不知道自己会被什么类型组合（你并没有代码上明确赋值让它知道），当然也就无法使用未知调用者teacher类型的功能，因此这里t.ShowA()时，执行showB()时函数接收者都是People,而非Teacher

5. 下面代码会触发异常吗？请详细说明
```go
func main() {
	runtime.GOMAXPROCS(1)
	int_chan := make(chan int, 1)
	string_chan := make(chan string, 1)
	int_chan <- 1
	string_chan <- "hello"
	select {
	case value := <-int_chan:
		fmt.Println(value)
	case value := <-string_chan:
		panic(value)
	}
}
```
答：有可能触发异常。

解析：单个chan如果不指定缓冲的话，彼此会阻塞。但结合select可以在多个chan之间等待执行，但是要符合以下原则：

- select中只有一个case能return,则立即执行

- 当同一时间多个case均能return则伪随机方式抽取任意一个执行
 
- 如果没有一个case能return则可以执行default部分逻辑

而题目中两个case中第二个有panic逻辑，如果多个case在同一时间内均能return的话，则本部分可能被执行触发报错。

6. 下面代码输出什么？
```go
func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}
func main() {
	a := 1                                             //line 1
	b := 2                                             //2
	defer calc("1", a, calc("10", a, b))  //3
	a = 0                                              //4
	defer calc("2", a, calc("20", a, b))  //5
	b = 1                                              //6
}
```
答：输出结果为:
```go
10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4
```
解析：解决此问题前要明确两个概念:

- 如问题1所讲，如果defer在return之前调用，可以改变输出的结果

- 函数调用时int参数会发生值拷贝

回头看这个问题，main执行部分defer calc()是函数嵌套类型的，内部同样调用了calc函数，而calc函数内部是有做return的，所以无论defer怎么摆放，两个defer内部的传参得到返回值会被首先执行，第一内部calc()函数被执行，打印结果是“10 1 2 3”，然后第二个内部calc()函数被执行，此时a=0赋值完成，所以打印结果是“20 0 2 2”，根据原则，该执行defer calc()函数了，后调用的先执行，所以先执行第二个defer calc(),此时a为0，内部函数计算结果为2，所以打印结果为“20 0 2 2”，最后执行最顶部defer calc(),但是此时a值应该是0还是1？答案是1，defer calc()虽然会延迟执行，但是赋值部分依然有效，所以此时a=1,b=3,所以首个defer calc()开始执行，执行结果是“1 1 3 4”。

7. 请写出以下输入内容
```go
func main() {
	s := make([]int, 5)
	s = append(s, 1, 2, 3)
	fmt.Println(s)
}
```
答：结果将输出：
```go
[0 0 0 0 0 1 2 3]
```

解析：make用于初始化数组，第二个参数指定生成数组的长度，但不像python,php等脚本语言，声明list或数组长度是根据元素个数自动变动的，它声明多少长度就是多少，且go中声明不指定初始值是，int类型默认值是0，所以s最开始这样[0,0,0,0,0],而append函数作用便是在数组或slice后面追加新元素，并且返回新的数组或slice，所以新的数组效果就变成了[0,0,0,0,0,1,2,3]。

8. 下面的代码有什么问题?
```go
type UserAges struct {
	ages map[string]int
	sync.Mutex
}
func (ua *UserAges) Add(name string, age int) {
	ua.Lock()
	defer ua.Unlock()
	ua.ages[name] = age
}
func (ua *UserAges) Get(name string) int {
	if age, ok := ua.ages[name]; ok {
		return age
	}
	return -1
}
```
答：在执行get方法时可能被panic

解析：虽然有sync.Mutex做写锁，但是map是并发读写不安全的。map属于引用类型，并发读写时多个协程是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系，会报<b>fatal error: concurrent map read and map write</b>。go已经在新版本中提供了安全使用map的方式。
- sync.Mutex互斥锁。

- sync.RWMutex读写锁，基于互斥的实现，可以加多个读锁或者一个写锁。

利用读写锁可以实现对map的安全访问，利用RWMutex进行读锁。
```go
type RWMutex
    func (rw *RWMutex) Lock() 
    func (rw *RWMutex) RLock()
    func (rw *RWMutex) RLocker() Locker
    func (rw *RWMutex) RUnlock()
    func (rw *RWMutex) Unlock()
```

9. 下面的迭代会有什么问题？
```go
func (set *threadSafeSet) Iter() <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		set.RLock()
		for elem := range set.s {
			ch <- elem
		}
		close(ch)
		set.RUnlock()
	}()
	return ch
}
```
答：内部迭代出现阻塞。默认初始化时无缓冲区，需要等待接收者读取后才能继续写入。

解析：chan在用make做初始化时可附带一个参数来指定缓冲区。默认初始化时无缓冲区会造成写入的元素直到被读取到才能继续写入，不然就一直阻塞。设置缓冲区大小后，写入数据后可连续写入到缓冲区中，直到缓冲区被占满。从chan中接收一次便可从缓冲区中释放一次。可以理解为chan是可以设置吞吐量的处理池。
来自社区fiisio的说明:
>ch := make(chan interface{}) 和 ch := make(chan interface{},1)是不一样的
无缓冲的 不仅仅是只能向 ch 通道放 一个值 而是一直要有人接收，那么ch <- elem才会继续下去，要不然就一直阻塞着，也就是说有接收者才去放，没有接收者就阻塞。
而缓冲为1则即使没有接收者也不会阻塞，因为缓冲大小是1只有当 放第二个值的时候 第一个还没被人拿走，这时候才会阻塞 

10. 以下代码能编译过去吗？为什么？
```go
package main
import (
	"fmt"
)
type People interface {
	Speak(string) string
}
type Stduent struct{}
func (stu *Stduent) Speak(think string) (talk string) {
	if think == "bitch" {
		talk = "You are a good boy"
	} else {
		talk = "hi"
	}
	return
}
func main() {
	var peo People = Stduent{}
	think := "bitch"
	fmt.Println(peo.Speak(think))
}
```
答：编译失败，值类型Student{}未实现接口People的方法，不能定义为People类型。

解析：func (stu \*Stduent) Speak(think string) (talk string) 是表示结构类型*Student的指针有提供该方法，但该方法并不属于结构类型Student的方法。因为Struct是值类型。

修改方法：
- 定义为指针 
```go
var peo People = &Studen{}
```
-方法定义在值类型上，指针类型本身是包含值类型的方法
```go
func (stu Stduent) Speak(think string) (talk string) { 
	//...
}
```
<h2 id="2">go语言的优势在哪里</h2>

我们学习一门语言的初衷都是因为它解决了某些方面特定的问题，go也是一样，摩尔定律告诉我们， 2004当时性能最高的个人计算机的cpu运行能力能达到2.4GHZ/s，快二十年过去了，今天我们见到的一些高配机型的cpu处理能力能睿频到4.1GHZ/s甚至更高，但这还只是0到10以内常数倍数的增长，电脑厂商想到了一些解决方案：
- 添加更多的核数，如个人电脑四核八核已经非常普遍，而商用服务器，16核、32核、64核层出不穷
- 加更多的缓存进来
- 超线程技术等

但是每种方法都有它的弊端，如果单纯的通过给计算机加核数来提高它的性能，但是加核越多，成本就越高，每个核上在做具体逻辑运算时要启自己的进程，每个进程又引入不同的线程协调工作，这就要涉及到多个线程同时运行，怎么能兼容处理能力和线程本身间资源不隔离，发生争抢了现象。单纯的加缓存进来，但是缓存有物理限制，缓存越大速度越慢，总之，解决问题的同时在引入新问题，新问题使得本来看上去会正比例提高机器的性能变得遥不可及。

![20200329193052](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200329193052.png)
<p class="caption">go在保持高效并发的同时保持了语言的优雅</p>

![20200329193215](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200329193215.png)
<p class="caption">go在保持性能接近原生c++/c语言的同时又对人类相当友好</p>

有没有一种方式能解决这个问题呢？我们今天的主角，golang就出现，简称go。

go为什么这么高效呢？go是一门静态的语言，如果你有c/c++语言基础的话，你会觉得非常熟悉，go特别好部署，只要能提供基础的glibc的运行环境，那服务就可以被部署起来，虽然不像动态高级语言一样，有很多的扩展包，但是25个关键字几乎可以实现其它语言提供的所有高级特性，代码格式化有gflib，无论你怎么写代码，在编辑器保存的时候想办法触发它，就可以让你的代码很规范，这样不同人共同维护分支也不会显得特别的错乱，go的gc机制如果不过度优化的话，跟jvm的性能是差不多的，但是与动态语言，比如说python相比，容易部署这点就足够python喝一壶的，因为python的部署工具确实太滥套了，什么virtualenv,conda,setuptools,pip,buildout,pip等，部署工具的多样导致生态的混乱，所以我从python2.7开始入门学python的时候，很多时间并不是在学习语言特性、编写业务逻辑解决问题，而是在搭建环境，在解决python该死的编码问题，几乎开始阶段的很大部分时间都浪费在这上面了。

同时go依托于channel和Goroutine的理念，让编写高并发软件变得异常的容易，几乎不会遇到线程死锁的问题，也能轻易发挥出多核cpu的性能，并行性能相当好，这和我大python相比又棋高一筹，在python中你想编写多线程或者多进程的应用，你得对计算机工作底层逻辑有清晰的了解，对于线程工作的方式有所了解，对于进程间共同工作如何划归任务有清晰的认识，并且由于有GIL的原因，多线程想发挥出字面意思的效能不太容易，会出现线程阻塞和争抢资源，不能有效的利用好多核服务器的多核资源。如果为了保险起见，每个进程只部署一个应用，又会造成资源的浪费，如果用系统内置的multiprocessing做线程管理的话，监控和管理方面，如果经验不够丰富又无法驾驭，总之，go把语言要解决问题的优势发挥到了最大，好的语言从学术角度上来讲，可能你提供的高级功能越多，你被更多人使用，你的扩展包越多说明你的生态越好，但是在海量数据场景频频出现的今天，工业级产品，性能和性价比可能是更多公司关注的东西，用更少的服务器给用户提供相对更好的用户体验就要求语言本身最好天然支持高并发，能把多核cpu的性能全部挖掘发挥到极致，而go恰恰就带着这些特质应运而生。

再有讲一下其他语言为什么慢的原因，看到很多文章都说如果go优化的好，可以达到jvm(java虚拟机)大致相同的处理性能
<h2 id="3">go为什么这么快</h2>

科技迅速进步，单台服务器的处理能力越来越强，迫使编程模式由原来的串行模式升级到并发模型。并发模型包含IO多路复用、多进程及多线程，这些模式都各有优劣，现在复杂度高的并发架构都是几种模型协同使用，不同场景应用不同的模型，扬长避短，发挥服务器的最大性能。而多线程，因为其轻量和易用，成为并发编程中使用最高的并发模型，包括后来衍生出的协程等其他子产品，也都是基于它。讲go为什么这么快之前，我们先来讲一下为什么c语言快，因为c语言直接把代码解析成二进制机器可读的编码直接执行了，而java和python正常都是有自己用于解析的虚拟机，解析成机器可读的执行语言，现在普遍都反映java也很快，实际是因为jvm的引入，就是java在虚拟机基础上又帮你封装了一层类似于mysql进程管理的机制，能更好的帮助系统做进程调配，所以它也很快，可见最直接最快的方式，就是能将代码直接解析成机器语言，直接执行，不经过虚拟机等中间转码的环节，go恰恰就吸纳了c/c++语言这个长处，同时又把gc和可引起性能损耗的环节都帮你优化掉了，并且使用更先进的线程管理模式，所以它才能如此快。那go的优点体现在哪些方面呢？

<b>Goroutine非常轻量</b>，主要体现在以下两个方面：

- <b>上下文切换代价小</b>，Goroutine上下文切换只涉及到三个寄存器（PC/SP/DX）值的修改；而对比线程的上下文切换有16个寄存器、PC、SP等

- <b>内存占有少</b>，线程栈空间通常是2M，Goroutine栈空间通常是2k

go之所以能够被调度，是经典的G-P-M模型，G就是Goroutine,P就是Proccess，M就是Machine，其实还要加上一个Sched,它是go的调度器，它维护有存储M和G的队列以及调度器一些状态信息，而schedule大致循环的机制大致就是从全局运行队列（GRQ Global Running Queue）、P的Local队列以及Wait队列中获取。M是os内核的抽象，代表着真正执行的内核资源（我内存一共5g分成了1000份，那么均分后的5k就是真正执行的内核资源），它在绑定p后进入schedule循环。于M来说，P为M的建立提供了context环境，如内存分配状态（mcache），任务队列（G）等。G是实际是并行得以实现的基础，单机Goroutine轻松起10w个，因为goroutine只占用2k内存。但是如果是多进程的模式，你只起1000线程，起码已经造成2G内存的占用了。整体起了那么多goroutine要保证启用了都能参与到具体的运算中不被浪费，这个调度都由goroutine在负责，proccess单机的上限是256。

![20200330085123](https://cdn.jsdelivr.net/gh/1060460048/MyImageRepository/img/20200330085123.png)
<p class="caption">经典地鼠推车搬砖</p>

这里面地鼠我们可以理解为M（Machine）,小车就是P（Process），车上的砖头就是G（Gortoutine），Goroutine不能独立进行工作，必须有Process的调度它在可以工作，而Goroutine中存储着它的运行堆栈、状态、以及任务函数是可以被复用的，同时M与G之间并不是状态绑定的关系，这是G可以跨M调度的基础。地鼠并不能直接来搬砖，它只有借助p才能使用上Goroutine才能完成搬砖这项活动，也就是说go处理任务能力的上限不是由Machine的数量决定的，而是由Process的数量来决定，如果Process还很多，就可以从其他地方借小车来帮着搬砖头，这个过程实际上就是内存线程。

>地鼠(Gopher)的工作任务是：工地上有若干砖头，地鼠借助小车把砖头运送到火种上去烧制。M 就可以看作图中的地鼠，P 就是小车，G 就是小车里装的砖。弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。Processor（P）：根据用户设置的  GoMAXPROCS 值来创建一批小车(P)。Goroutine(G)：通过 Go 关键字就是用来创建一个  Goroutine，也就相当于制造一块砖(G)，然后将这块砖(G)放入当前这辆小车(P)中。Machine (M)：地鼠(M)不能通过外部创建出来，只能砖(G)太多了，地鼠(M)又太少了，实在忙不过来，刚好还有空闲的小车(P)没有使用，那就从别处再借些地鼠(M)过来直到把小车(P)用完为止。这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。需要注意的是：地鼠(M)  如果没有小车(P)是没办法运砖的，小车(P)的数量决定了能够干活的地鼠(M)数量，在 Go 程序里面对应的是活动线程数；(--引用自腾讯技术工程)

在很少机器的基础上支持大量的Process，所以说Process没有上限，你通过内存线程不断增加M的数量，那么，对于Goroutine的搬运速度势必会越来越快，又不会带来线程切换时带来的内存损耗，Goroutine只占几kb的内存，效率相当的高。

有几种使用的方式:

- 任务窃取，在实际场景下有的Gorontine运的快，有的Goroutine运的慢，势必导致忙的忙死，闲的闲死，Go肯定是不允许有摸鱼的Goroutine存在，为了充分利用计算资源，提高go对并行任务的处理能力，提升整体处理效率，当每个P与G不均衡时，调试器允许GRQ（全局任务队列）或者其它P的LGR（本地任务队列）获取G执行。


spark实现类似spoop分布式替代了早期定期单机全量抓取mysql，那么，头条之所以有今天成功的原因是什么呢？

databus是如何实现单机代理的，怎么封装的kafka从而对数据写入，异步写入，buffer统一配置等feature这些feature能够实现，核心系统是哪一个呢？

kafka的数据通过dumps落地到HDFS，storm原来是替代了单机数据的上传，实际是多机分布式上传，下面有几条线可以走，一条线是python通过HadoopStreaming来实现MapReduce的任务，另一种方式是使用spark直接生成parquet数据，spark相比于mapreduce最大的特点就是有更丰富的处理原语，代码实现更简洁。

什么是高层次的数据表， 怎么用hiveSQL来描述El，el是啥呢？

我们知道kafka的是个基于大数据的消息队列管理系统，所实时产生的feed推送到kafka中，然后在把队列消耗掉，然后底层用storm做大数据运算，

为什么要把hadoop,hive,spark，kylin等封成工具呢？
hadoop节点3000个是什么概念，数据两百亿条是什么概念，服务器总量40000台都是什么配置的，

头条有使用go语言吗？

头条把信息安全放在首位，成立了信息安全部分，通过协同过滤和人工审核，基本能保证数据的如回率在多少多少，数据安全性涉及到信息流中是否存在反动言论，是否有黄色图片，是否有攻击性的语言评论，有粗枝滥造的文章，标题党，昨天看到说由于对用户行为进行监测，假如用户有一个运作点击了x，即不感兴趣，会对关键词降权，而不是直接把文章或者用户给删除掉

go是一门静态的语言，如果你有c/c++语言基础的话，你会觉得非常熟悉，go特别好部署，只要能提供基础的glibc的运行环境，那服务就可以被部署起来，虽然不像动态高级语言一样，有很多的扩展包，但是25个关键字几乎可以实现其它语言提供的所有高级特性，代码格式化有gflib，无论你怎么写代码，在编辑器保存的时候想办法触发它，就可以让你的代码很规范，这样不同人共同维护分支也不会显得特别的错乱，go的gc机制如果不过度优化的话，跟jvm的性能是差不多的，但是与动态语言，比如说python相比，容易部署这点就足够python喝一壶的，因为python的部署工具确实太滥套了，什么virtualenv,conda,



信息量越大的书，读起来就越要弄清楚涉及的前世今生，因为知识并不是由一个个孤立的点组成的，而是所有的知识形成了网络，这个网络互相有关系的点越多，这个基础越夯实，你不断学习更高阶的思维方式，更高阶的编码方式，有时候你觉得你自己代码编的很滥，但是你只要坚持不断的学习，那么你慢慢会发现，你也摸出了语言组织的一些高级的技巧，换一种说法，你也有高手那种编程思维了。